A seguir, reescrevo a entidade `PetSearch` com persist√™ncia da imagem diretamente no banco de dados usando anota√ß√£o `@Lob`. Essa abordagem √© recomendada apenas se:

* o volume de dados bin√°rios for pequeno (ex.: thumbnails, imagens comprimidas),
* e se n√£o houver acesso frequente ou distribui√ß√£o p√∫blica da imagem diretamente por link (como seria o caso em S3).

---

## üß± 1. Entidade `PetSearch` com `@Lob`

```java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PetSearch {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    private Pet pet;

    @ManyToOne(optional = false)
    private Person reportedBy;

    @Enumerated(EnumType.STRING)
    private SearchRole reporterRole;

    private LocalDateTime disappearanceDate;

    private String location;

    @Lob
    @Basic(fetch = FetchType.LAZY) // boa pr√°tica para performance
    private byte[] photo;

    @Column(columnDefinition = "TEXT")
    private String additionalNotes;
}
```

---

## üì§ 2. Atualiza√ß√£o dos DTOs

### `PetSearchRequestDTO`

```java
@Data
public class PetSearchRequestDTO {
    private Long petId;
    private Long personId;
    private SearchRole reporterRole;
    private LocalDateTime disappearanceDate;
    private String location;
    private byte[] photo; // bin√°rio direto no request
    private String additionalNotes;
}
```

### `PetSearchResponseDTO`

```java
@Data
public class PetSearchResponseDTO {
    private Long id;
    private Long petId;
    private Long personId;
    private String petName;
    private String personName;
    private SearchRole reporterRole;
    private LocalDateTime disappearanceDate;
    private String location;
    private byte[] photo; // retorno da imagem
    private String additionalNotes;
}
```

---

## üîÅ 3. Mapper `PetSearchMapper` (sem mudan√ßas)

Como MapStruct lida com mapeamento autom√°tico de arrays, nenhuma modifica√ß√£o √© necess√°ria, desde que os campos `photo` estejam com o mesmo nome e tipo em ambas as classes.

```java
@Mapper(componentModel = "spring")
public interface PetSearchMapper {

    @Mapping(target = "pet.id", source = "petId")
    @Mapping(target = "reportedBy.id", source = "personId")
    PetSearch toEntity(PetSearchRequestDTO dto);

    @Mapping(target = "petId", source = "pet.id")
    @Mapping(target = "personId", source = "reportedBy.id")
    @Mapping(target = "petName", source = "pet.name")
    @Mapping(target = "personName", source = "reportedBy.name")
    PetSearchResponseDTO toDto(PetSearch entity);
}
```

---

## ‚ö†Ô∏è Considera√ß√µes t√©cnicas

* **Armazenamento bin√°rio no banco** com `@Lob` deve ser utilizado com cautela:

  * Afeta desempenho em leitura de listas (ex.: consultas sem `fetch = LAZY`)
  * Dificulta cache, CDN e distribui√ß√£o de imagens
  * Recomendado apenas para sistemas internos ou com imagens pequenas

* Alternativa mais escal√°vel:

  * Armazenar a imagem em servi√ßo externo (S3, GCP, Azure Blob, etc.)
  * Salvar apenas a URL no campo `photoUrl` (como no exemplo anterior)

---

## üìö Refer√™ncias t√©cnicas

* [Hibernate ORM - Large Objects](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#basic-lob)
* [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
* Silberschatz, A.; Korth, H. F.; Sudarshan, S. *Database System Concepts*, McGraw-Hill, 2010.

---

Se desejar, posso incluir:

* Upload via `multipart/form-data` no controller
* Endpoint espec√≠fico para recupera√ß√£o de imagem
* Convers√£o entre `MultipartFile` e `byte[]` com utilit√°rios do Spring

Deseja que eu prossiga com isso?
A seguir, reescrevo a entidade `PetSearch` com persist√™ncia da imagem diretamente no banco de dados usando anota√ß√£o `@Lob`. Essa abordagem √© recomendada apenas se:

* o volume de dados bin√°rios for pequeno (ex.: thumbnails, imagens comprimidas),
* e se n√£o houver acesso frequente ou distribui√ß√£o p√∫blica da imagem diretamente por link (como seria o caso em S3).

---

## üß± 1. Entidade `PetSearch` com `@Lob`

```java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PetSearch {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    private Pet pet;

    @ManyToOne(optional = false)
    private Person reportedBy;

    @Enumerated(EnumType.STRING)
    private SearchRole reporterRole;

    private LocalDateTime disappearanceDate;

    private String location;

    @Lob
    @Basic(fetch = FetchType.LAZY) // boa pr√°tica para performance
    private byte[] photo;

    @Column(columnDefinition = "TEXT")
    private String additionalNotes;
}
```

---

## üì§ 2. Atualiza√ß√£o dos DTOs

### `PetSearchRequestDTO`

```java
@Data
public class PetSearchRequestDTO {
    private Long petId;
    private Long personId;
    private SearchRole reporterRole;
    private LocalDateTime disappearanceDate;
    private String location;
    private byte[] photo; // bin√°rio direto no request
    private String additionalNotes;
}
```

### `PetSearchResponseDTO`

```java
@Data
public class PetSearchResponseDTO {
    private Long id;
    private Long petId;
    private Long personId;
    private String petName;
    private String personName;
    private SearchRole reporterRole;
    private LocalDateTime disappearanceDate;
    private String location;
    private byte[] photo; // retorno da imagem
    private String additionalNotes;
}
```

---

## üîÅ 3. Mapper `PetSearchMapper` (sem mudan√ßas)

Como MapStruct lida com mapeamento autom√°tico de arrays, nenhuma modifica√ß√£o √© necess√°ria, desde que os campos `photo` estejam com o mesmo nome e tipo em ambas as classes.

```java
@Mapper(componentModel = "spring")
public interface PetSearchMapper {

    @Mapping(target = "pet.id", source = "petId")
    @Mapping(target = "reportedBy.id", source = "personId")
    PetSearch toEntity(PetSearchRequestDTO dto);

    @Mapping(target = "petId", source = "pet.id")
    @Mapping(target = "personId", source = "reportedBy.id")
    @Mapping(target = "petName", source = "pet.name")
    @Mapping(target = "personName", source = "reportedBy.name")
    PetSearchResponseDTO toDto(PetSearch entity);
}
```

---

## ‚ö†Ô∏è Considera√ß√µes t√©cnicas

* **Armazenamento bin√°rio no banco** com `@Lob` deve ser utilizado com cautela:

  * Afeta desempenho em leitura de listas (ex.: consultas sem `fetch = LAZY`)
  * Dificulta cache, CDN e distribui√ß√£o de imagens
  * Recomendado apenas para sistemas internos ou com imagens pequenas

* Alternativa mais escal√°vel:

  * Armazenar a imagem em servi√ßo externo (S3, GCP, Azure Blob, etc.)
  * Salvar apenas a URL no campo `photoUrl` (como no exemplo anterior)

---

## üìö Refer√™ncias t√©cnicas

* [Hibernate ORM - Large Objects](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#basic-lob)
* [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
* Silberschatz, A.; Korth, H. F.; Sudarshan, S. *Database System Concepts*, McGraw-Hill, 2010.

---

Se desejar, posso incluir:

* Upload via `multipart/form-data` no controller
* Endpoint espec√≠fico para recupera√ß√£o de imagem
* Convers√£o entre `MultipartFile` e `byte[]` com utilit√°rios do Spring

Deseja que eu prossiga com isso?
